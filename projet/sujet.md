| [![uB](https://upload.wikimedia.org/wikipedia/fr/c/cc/Logo_EPE_Universit%C3%A9_Bourgogne_Europe.svg)](https://u-bourgogne.fr/) | Polytech Dijon - 4A - ILIA - DevOps <br/><br/> **[ EXAMEN PRATIQUE ]** | [![ESIREM](https://polytech.ube.fr/wp-content/uploads/2023/02/Logo_Reseau_Polytech.svg_-300x191.png)](https://esirem.u-bourgogne.fr/) |
|--------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
|                                                                                                                                |                                                                        |                                                                                                                                       |

# Sujet projet - Ann√©e 2025

> [!warning]
> Avant de commencer, veiller √† prendre connaissance des attentes projet [./README.md#exigences-du-projet](./README.md#exigences-du-projet).

Ce projet est √† rendre au plus tard le `Vendred 14 novembre 2025 √† 23h59`. √Ä partir de cette date, aucun changement (commit, issue ou pull_request) ne sera pris en compte pour la notation.

![PolyStatus](https://github.com/user-attachments/assets/ad8a7ec4-eb29-4ac4-ab15-2f6513b8f4f1)

<br/>

Au cours de ce projet, nous allons r√©aliser les diff√©rentes composantes microservices de suivi d'incident, comme le fait par exemple [DownDetector](https://downdetector.fr/).

## PolyStatus üöÄ

Concevoir une grappe de microservice compos√©e d'API simples `Python/Flask` et d'un frontend. Cet ensemble permettra de r√©pondre aux fonctionnalit√©s suivantes :

- **Permettre le suivi d'incident** ‚Äî cr√©ation, suivi, timeline, changement de statut, assignation et postmortem d√©taill√©.
- **G√©rer diff√©rent type d'utilisateurs et des SREs** pour permettre d'attribuer les actions √† r√©aliser, les r√©f√©rents des incidents.
- R√©cup√©rer les status officiels et annonces des fournisseurs, voir les liens de cause √† effet entre les diff√©rents providers.
- **Surveillance automatique** des status pages cloud (AWS, GCP, Cloudflare‚Ä¶) et cr√©ation d‚Äôincidents √† partir de ces sources.

Via la d√©claration de route `GET` et `POST` vous d√©finirez les fonctions pour r√©pondre aux fonctionnalit√©s si dessus ‚òùÔ∏è

**Polytex** sera compos√© d'au moins 4 microservice. 

- Gestion/suivi des incidents.
- Gestion des profils utilisateurs (CRUD) et identit√©.
- Gestion des communications (status, bani√®re, emails).
- Recup√©ration de status des autres CSP.
- Serveur de feature flags.
- Frontend.

> [!note]
> Chacun des microservices et le frontend feront l'objet d'un dossier dans le d√©p√¥t. (cf. [./README.md#exigences-du-projet](./README.md#exigences-du-projet))

### D√©tails d'impl√©mentation

#### Routes par microservice

Afin de permettre aux diff√©rents microservices de communiquer entre eux, nous allons d√©finir des standards. Standards qui
permettront de savoir comment appeler chaque microservice et quel sera le format de la r√©ponse re√ßue.
Ces standards devront, pour chaque microservice, √™tre r√©pertori√© dans un fichier `swagger.yaml`.

#### Gestion des objets (API REST et JSON)

L'envoie et le retour de donn√©es dans les requ√™tes et les reponses `HTTP` peut √™tre simplifi√© via l'utilisation de structure [`JSON`](https://fr.wikipedia.org/wiki/JavaScript_Object_Notation). Vous pourrez g√©rer vos traitements et/ou transformation de donn√©e ou de message dans les routes de votre API.

> [!tip]
> Avant de mettre en place les bases Redis, vous pouvez utiliser des dictionnaires en variables locales dans le microservice pour tester vos routes et vos fonctionnalit√©s.

Testez vos routes avec la commande `curl`.

> [!note]
> Gardez en t√™te l'objectif d'autonomie des microservices, l'id√©e est de cr√©er des [API REST ](https://www.redhat.com/fr/topics/api/what-is-a-rest-api).

#### Exemple de route

Pour des **exemples** de routes d√©finit comme suit, vous trouverez un **exemple** de swagger associ√©.

> [!caution]
> Le fichier `swagger.yaml` doit √™tre √† jour en tout temps, pour permettre aux autres √©quipes de savoir comment requ√™ter votre API.

**users**

| Route                     | Action                                            | Reponse                                                 |
|---------------------------|---------------------------------------------------|---------------------------------------------------------|
| `POST /api/v1/users`      | Permet de cr√©er un utilisateur.                   | Retourne un HTTP code de succ√®s (HTTP 200). (si succ√®s) |
| `POST /api/v1/auth/login` | Permet la connection de l'utilisateur.            | Retourne un token.                                      |
| `GET /api/v1/users`       | Permet de r√©cup√©rer la liste des utilisateurs.    | Retourne une liste.                                     |
| `GET /api/v1/users/<id>`  | Permet de r√©cup√©rer les d√©tails d'un utilisateur. | Retourne un objet JSON repr√©sentant un utilisateur.     |
| `PUT /api/v1/users/<id>`  | Permet de modifier les d√©tails d'un utilisateur.  | Retourne un HTTP code de succ√®s.                        |

> Exemple de swagger pour le microservice utilisateurs: [./swaggers/users.yaml](./swaggers/users.yaml)

**incidents**

| **Route / Endpoint**                     | **Action**                                                                            | **R√©ponse**                                             |
|------------------------------------------|---------------------------------------------------------------------------------------|---------------------------------------------------------|
| `POST /api/v1/incidents`                 | Cr√©er un nouvel incident                                                              | Retourne un **objet JSON** repr√©sentant l‚Äôincident cr√©√© |
| `GET /api/v1/incidents`                  | Lister les incidents                                                                  | Retourne une **liste JSON** d‚Äôincidents                 |
| `GET /api/v1/incidents/<id>`             | R√©cup√©rer les d√©tails d‚Äôun incident par id                                            | Retourne un **objet JSON** repr√©sentant l‚Äôincident      |
| `POST /api/v1/incidents/<id>/assign`     | Assigner un incident                                                                  | Retourne l‚Äôincident mis √† jour                          |
| `POST /api/v1/incidents/<id>/status`     | Mettre √† jour le **statut** d‚Äôun incident (`open`, `mitigated`, `resolved`)           | Retourne l‚Äôincident avec son nouveau statut             |
| `POST /api/v1/incidents/<id>/timeline`   | Ajouter un **√©v√©nement** dans la timeline (note, mise √† jour, mitigation, r√©solution) | Retourne un code HTTP 200  (si succ√®s)                  |
| `POST /api/v1/incidents/<id>/postmortem` | Soumettre ou modifier le **postmortem** d‚Äôun incident                                 | Retourne un code HTTP 200 (si succ√®s)                   |

> Exemple de swagger pour le microservice d'incident: [./swaggers/incidents.yaml](./swaggers/incidents.yaml)

**communication**

| **Route / Endpoint**               | **Action**                                                                              | **R√©ponse**                                                                               |
| ---------------------------------- | --------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `POST /api/v1/public/announce`     | Publier une **annonce publique** li√©e √† un incident (message et √©tat)                   | Retourne un **objet JSON** repr√©sentant l‚Äôannonce cr√©√©e (**HTTP 201**)                    |
| `GET /api/v1/public/status`        | R√©cup√©rer le **statut public** global (incidents en cours ou r√©cents)                   | Retourne une **liste JSON** d‚Äôincidents publics et leurs derniers messages (**HTTP 200**) |
| `POST /api/v1/subscriptions/email` | Ajouter une **adresse email** √† la liste des abonn√©s pour recevoir les annonces         | Retourne un **code HTTP 201** (succ√®s de l‚Äôabonnement)                                    |
| `POST /api/v1/webhooks`            | Enregistrer un **webhook** pour notifier un syst√®me externe lors de nouveaux √©v√©nements | Retourne un **code HTTP 201** (webhook enregistr√© avec succ√®s)                            |

> Exemple de swagger pour le microservice de communications: [./swaggers/comms.yaml](./swaggers/comms.yaml)

**csp-ingestor**

| **Route / Endpoint**                           | **Action**                                                                         | **R√©ponse**                                                            |
|------------------------------------------------|------------------------------------------------------------------------------------|------------------------------------------------------------------------|
| `POST /api/v1/csp/providers`                   | Ajouter un **fournisseur cloud** (CSP) √† surveiller, avec son flux de statut       |  Retourne un **code HTTP 201** confirmant l‚Äôenregistrement du provider |
| `POST /api/v1/csp/refresh?provider=cloudflare` | Rafra√Æchir manuellement les **√©v√©nements de statut** pour un provider donn√©        | Retourne un **objet JSON** avec le r√©sultat du rafra√Æchissement        |
| `GET /api/v1/csp/events?active=true`           | R√©cup√©rer la liste des **incidents actifs d√©tect√©s** chez les fournisseurs CSP     | Retourne une **liste JSON** d‚Äô√©v√©nements                               |
| `POST /api/v1/incidents`                       | Cr√©ation d‚Äôun incident interne lorsqu‚Äôun √©v√©nement critique est d√©tect√© sur un CSP | Retourne un **objet JSON** de l‚Äôincident cr√©√© avec le champ            |

> Exemple de swagger pour le microservice csp-ingestor: [./swaggers/csp.yaml](./swaggers/csp.yaml)

**flags**

| **Route / Endpoint**                 | **Action**                                                                             | **R√©ponse**                                                                                          |
|--------------------------------------|----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| `GET /flags?user=<user>&role=<role>` | R√©cup√©rer la liste des **feature flags** applicables √† un utilisateur selon son r√¥le   | Retourne un **objet JSON** contenant les flags et leurs variations                                   |
| `GET /admin/flags`                   | R√©cup√©rer la liste des **feature flag**  existant                                      | Retourne la liste des features flags existants                                                       |
| `GET /admin/flags`                   | R√©cup√©rer la liste des **feature flag**  existant                                      | Retourne un objets avec des listes des features flags activ√©s par un utilisateur et/ou par un groupe |
| `POST /admin/flags/`                 | Cr√©er ou mettre √† jour un **feature flag**                                             | Retourne un **code HTTP 201** ou **200** selon la cr√©ation ou la mise √† jour                         |
| `POST /admin/toggle/<key>`           | Activer ou d√©sactiver un **feature flag** existant                                     | Retourne un **code HTTP 200** (si succ√®s de la modification)                                         |

> Exemple de swagger pour le microservice de feature flags: [./swaggers/flags.yaml](./swaggers/flags.yaml)

> [!tip]
> Le YAML n'est pas clair ? Vous pouvez le passer dans https://editor.swagger.io

---

### Informations fonctionnelles

#### Annonces

Les annonces seront majoritairement g√©r√©es au niveau de l'application mais vous pouvez mettre en place une interconnection avec un service SMTP.

#### CSP-ingestor

L'ingestion des informations des Cloud Service Provider peut se faire par scrapping de site web, mais je vous recommande d'int√©grer dans un premier temps les CSP qui propose une APIs d'incident.

- https://www.cloudflarestatus.com/api
- https://www.githubstatus.com/api
- https://status.cloud.google.com/incidents.json
- https://status.atlassian.com/api

Autre page √† int√©grer: [AWS](https://health.aws.amazon.com/health/status), [GitLab](https://status.gitlab.com/), [Docker](https://www.dockerstatus.com/).
Ou toute autre application de votre choix ! üöÄ

> [!tip]
> Vous pouvez aussi mettre en place de l'int√©gration de flux RSS.
> 
> Si votre application pr√©f√©r√©e ne propose pas de status page, vous pouvez faire un appel HTTP pour confirmer leur disponibilit√© !

---

### Stockage

Pour externaliser le stockage des donn√©es et garantir leurs conservations en cas red√©marrage des microservices, le tout dans une base rapide et sans contrainte, vous pouvez utiliser `redis`.

> [!important]
> Vous √™tes libre de choisir le d√©coupage pour le stockage, √©changer autour des possibilit√©s et documenter les via issues et fichier Markdown.

#### Qu'est ce que Redis ?

`Redis` est une base de donn√©e cl√©/valeur qui vous permettra de stocker de la donn√©e sous forme de dictionnaire.

Rien a coder, vous pouvez utiliserer Redis comme serveur de donn√©es, lanc√© dans un conteneur sur votre machine. Accessible une fois lancer via `localhost` sur le port `6379`.

Dans un autre terminal vous pouvez lancer `redis` frontalement via la commande :

```bash
docker run --name myredis --rm -p 6379:6379 redis
```

> [!tip]
> Utilisez l'outil `redis-cli` pour acc√©der √† `redis` directement sans script `python`. (c.f. [Installer Redis](https://redis.io/docs/latest/operate/oss_and_stack/install/archive/install-redis/))

Si vous stockiez vos users, communications et incidents dans des variables dictionnaires locales, vous pouvez maintenant la remplacer par un stockage dans le serveur `redis`.

#### Exemple: stocker les users, incidents via Redis

Vous pouvez stocker dans plusieurs bases Redis.

Une base contenant les .

*Exemple :* `key=INC-timestamp, value=‚Äô{‚Äúsource‚Äù: ‚Äúusername‚Äù, ‚Äúduree‚Äù: ‚ÄùYYYY.MM.DD.HH.MM.SS‚Äù, ‚Äútitre‚Äù: ‚Äùtitre‚Äù, "description": "incident √† fort impact"}‚Äô`

Une base contenant les utilisateurs dans laquelle la cl√© sera le nom d‚Äôutilisateur et en valeur la liste des cl√©s de ses incidents suivis.

*Exemple :* `key=username, value=[INC-timestamp_1, INC-timestamp_2, INC-timestamp_3]`

L'architecture ci-dessus est un exemple. Vous √™tes libre de choisir une autre architecture, mais elle doit fonctionner üòâ
